{"version":3,"file":"stick-it.min.js","sources":["../src/helpers.js","../src/stick-it.js"],"sourcesContent":["/**\r\n * Throttles a function so it is only called once within the specified time window.\r\n * This prevents performance issues from running a function repeatedly during scroll or resize events.\r\n *\r\n * @since 1.0.0\r\n * @param {Function} func - The function to throttle.\r\n * @param {number} wait - The number of milliseconds to wait before allowing another call.\r\n * @returns {Function} A throttled version of the provided function.\r\n */\r\nexport function throttle(func, wait) {\r\n  let context, args, result, timeout = null\r\n  let previous = 0\r\n\r\n  const later = () => {\r\n    previous = Date.now()\r\n    timeout = null\r\n    result = func.apply(context, args)\r\n    context = args = null\r\n  }\r\n\r\n  return function(...innerArgs) {\r\n    const now = Date.now()\r\n    const remaining = wait - (now - previous)\r\n    context = this\r\n    args = innerArgs\r\n\r\n    if (remaining <= 0) {\r\n      clearTimeout(timeout)\r\n      timeout = null\r\n      previous = now\r\n      result = func.apply(context, args)\r\n      context = args = null\r\n    } else if (!timeout) {\r\n      timeout = setTimeout(later, remaining)\r\n    }\r\n    return result\r\n  }\r\n}\r\n\r\n/**\r\n * Retrieves the current vertical scroll position of the page.\r\n *\r\n * @returns {number} The current vertical scroll position in pixels.\r\n */\r\nexport function getScrollY() {\r\n  // Prefer window.scrollY for modern browsers.\r\n  // If scrollY is undefined, fallback to scrollTop for legacy browsers.\r\n  return (typeof window.scrollY === 'number')\r\n        ? window.scrollY\r\n        : (document.documentElement || document.body.parentNode || document.body).scrollTop\r\n}\r\n\r\n/**\r\n * Calculates the vertical position of an element relative to the top of the document.\r\n *\r\n * @param {HTMLElement} elem - The element whose position should be determined.\r\n * @param {string} side - Which side of the element to use for calculation ('top' or 'bottom').\r\n * @returns {number} The element's vertical position in pixels.\r\n */\r\nexport function getElementYPosition(elem, side) {\r\n  let pos = 0\r\n  const elemHeight = elem.offsetHeight\r\n\r\n  let currentElem = elem\r\n  while (currentElem) {\r\n    pos += currentElem.offsetTop\r\n    currentElem = currentElem.offsetParent\r\n  }\r\n\r\n  if (side === 'bottom') {\r\n    pos += elemHeight\r\n  }\r\n\r\n  return pos\r\n}\r\n","import { throttle, getScrollY, getElementYPosition } from './helpers.js'\r\n\r\n/**\r\n * @typedef {Object} StickItClasses\r\n * @property {string} clone CSS class applied to the cloned element.\r\n * @property {string} stick CSS class applied when the element is stuck.\r\n * @property {string} unstick CSS class applied when the element is unstuck.\r\n */\r\n\r\n/**\r\n * @typedef {Object} StickItOptions\r\n * @property {number|string} offset - Numeric offset (in px) or a CSS selector string indicating when the element should \"stick\".\r\n * @property {string} offsetSide - Side of the element used for calculating offset ('top' or 'bottom').\r\n * @property {StickItClasses} classes - CSS classes used for styling the cloned/stuck elements.\r\n * @property {number} throttle - Throttle delay in ms for scroll and resize events.\r\n * @property {Function} onInit - Callback fired after initialization.\r\n * @property {Function} onStick - Callback fired when the element becomes stuck.\r\n * @property {Function} onUnstick - Callback fired when the element becomes unstuck.\r\n * @property {Function} onDestroy - Callback fired after destroying the instance.\r\n */\r\n\r\n/**\r\n * StickIt\r\n *\r\n * Description:\r\n * StickIt is a utility that clones a specified element and \"sticks\" it\r\n * to the top of the viewport once the user scrolls past a certain threshold (offset).\r\n * This can be used to create sticky headers or navigation bars that remain visible as the user scrolls.\r\n *\r\n * This project is a custom modernized version of headhesive.js by Mark Goodyear.\r\n *\r\n * @version 2.0.0\r\n * @author Chayson Media Group\r\n * @license MIT\r\n *\r\n * Original Project:\r\n * Headhesive.js by Mark Goodyear\r\n * @see https://github.com/markgoodyear/headhesive.js\r\n *\r\n * Modernized and adapted by Chayson Media Group\r\n * @see https://chayson.com/\r\n */\r\nexport default class StickIt {\r\n  /**\r\n   * Creates a new StickIt instance.\r\n   * @param {HTMLElement|string} elem - The target element (or a selector string) to make sticky.\r\n   * @param {Partial<StickItOptions>} [options={}] - Custom configuration options.\r\n   */\r\n  constructor(elem, options = {}) {\r\n    if (!('querySelector' in document && 'addEventListener' in window)) {\r\n      // Feature test fails, do not initialize.\r\n      return\r\n    }\r\n\r\n    /**\r\n     * @type {boolean} visible - Indicates whether the cloned element is currently stuck.\r\n     */\r\n    this.visible = false\r\n\r\n    /**\r\n     * @type {StickItOptions} options - Merged configuration options.\r\n     */\r\n    this.options = Object.assign({\r\n      offset: 300,\r\n      offsetSide: 'top',\r\n      classes: {\r\n        clone: 'stickit',\r\n        stick: 'stickit-stick',\r\n        unstick: 'stickit-unstick'\r\n      },\r\n      throttle: 250,\r\n      onInit: () => {},\r\n      onStick: () => {},\r\n      onUnstick: () => {},\r\n      onDestroy: () => {}\r\n    }, options)\r\n\r\n    /**\r\n     * @type {HTMLElement} elem - The target element to stick.\r\n     */\r\n    this.elem = (typeof elem === 'string') ? document.querySelector(elem) : elem\r\n\r\n    // Proceed with initialization only if elem exists.\r\n    if (this.elem) {\r\n      this.init()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Initializes the StickIt instance:\r\n   * - Clones the target element and inserts it into the DOM.\r\n   * - Calculates the scroll offset threshold.\r\n   * - Sets up scroll and resize event listeners with throttling.\r\n   * - Calls the onInit callback.\r\n   */\r\n  init() {\r\n    // Clone the element and add the clone class(es).\r\n    this.clonedElem = this.elem.cloneNode(true)\r\n\r\n    const cloneClasses = Array.isArray(this.options.classes.clone)\r\n      ? this.options.classes.clone\r\n      : [this.options.classes.clone]\r\n\r\n    cloneClasses.forEach(cls => this.clonedElem.classList.add(cls))\r\n\r\n    document.body.insertBefore(this.clonedElem, document.body.firstChild)\r\n\r\n    // Determine the initial scroll offset.\r\n    this._setScrollOffset()\r\n\r\n    // Bind and throttle update methods.\r\n    this._throttledUpdate = throttle(this.update.bind(this), this.options.throttle)\r\n    this._throttledScrollOffset = throttle(this._setScrollOffset.bind(this), this.options.throttle)\r\n\r\n    // Listen to scroll and resize events.\r\n    window.addEventListener('scroll', this._throttledUpdate, false)\r\n    window.addEventListener('resize', this._throttledScrollOffset, false)\r\n\r\n    // Call the init callback.\r\n    this.options.onInit.call(this)\r\n  }\r\n\r\n  /**\r\n   * Calculates and sets the scroll offset at which the element should become stuck.\r\n   * If the offset is a number, it uses that directly.\r\n   * If the offset is a string (selector), it finds that element and calculates its position.\r\n   * @private\r\n   */\r\n  _setScrollOffset() {\r\n    const { offset, offsetSide } = this.options\r\n    if (typeof offset === 'number') {\r\n      this.scrollOffset = offset\r\n    } else if (typeof offset === 'string') {\r\n      const target = document.querySelector(offset)\r\n      if (target) {\r\n        this.scrollOffset = getElementYPosition(target, offsetSide)\r\n      } else {\r\n        this.scrollOffset = 300 // Default fallback if the selector isn't found.\r\n      }\r\n    } else {\r\n      throw new Error(`Invalid offset: ${offset}`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Destroys the StickIt instance:\r\n   * - Removes the cloned element from the DOM.\r\n   * - Removes scroll and resize event listeners.\r\n   * - Calls the onDestroy callback.\r\n   */\r\n  destroy() {\r\n    if (this.clonedElem && this.clonedElem.parentNode) {\r\n      document.body.removeChild(this.clonedElem)\r\n    }\r\n    window.removeEventListener('scroll', this._throttledUpdate)\r\n    window.removeEventListener('resize', this._throttledScrollOffset)\r\n\r\n    this.options.onDestroy.call(this)\r\n  }\r\n\r\n  /**\r\n   * Makes the element \"stick\" by adding the sticky class and removing any unstick class.\r\n   * Also sets the visible state to true and calls the onStick callback.\r\n   */\r\n  stick() {\r\n    if (!this.visible) {\r\n      this.clonedElem.classList.remove(this.options.classes.unstick)\r\n      this.clonedElem.classList.add(this.options.classes.stick)\r\n      this.visible = true\r\n      this.options.onStick.call(this)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Makes the element \"unstick\" by adding the unstick class and removing the stick class.\r\n   * Also sets the visible state to false and calls the onUnstick callback.\r\n   */\r\n  unstick() {\r\n    if (this.visible) {\r\n      this.clonedElem.classList.remove(this.options.classes.stick)\r\n      this.clonedElem.classList.add(this.options.classes.unstick)\r\n      this.visible = false\r\n      this.options.onUnstick.call(this)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks the current scroll position and decides whether the element should\r\n   * stick or unstick.\r\n   */\r\n  update() {\r\n    if (getScrollY() > this.scrollOffset) {\r\n      this.stick()\r\n    } else {\r\n      this.unstick()\r\n    }\r\n  }\r\n}\r\n"],"names":["throttle","func","wait","context","args","result","timeout","previous","later","Date","now","apply","innerArgs","remaining","this","clearTimeout","setTimeout","constructor","elem","options","document","window","visible","Object","assign","offset","offsetSide","classes","clone","stick","unstick","onInit","onStick","onUnstick","onDestroy","querySelector","init","clonedElem","cloneNode","Array","isArray","forEach","cls","classList","add","body","insertBefore","firstChild","_setScrollOffset","_throttledUpdate","update","bind","_throttledScrollOffset","addEventListener","call","scrollOffset","Error","target","side","pos","elemHeight","offsetHeight","currentElem","offsetTop","offsetParent","getElementYPosition","destroy","parentNode","removeChild","removeEventListener","remove","scrollY","documentElement","scrollTop"],"mappings":";;;;;;wOASO,SAASA,EAASC,EAAMC,GAC7B,IAAIC,EAASC,EAAMC,EAAQC,EAAU,KACjCC,EAAW,EAEf,MAAMC,EAAQ,KACZD,EAAWE,KAAKC,MAChBJ,EAAU,KACVD,EAASJ,EAAKU,MAAMR,EAASC,GAC7BD,EAAUC,EAAO,IAAI,EAGvB,OAAO,YAAYQ,GACjB,MAAMF,EAAMD,KAAKC,MACXG,EAAYX,GAAQQ,EAAMH,GAahC,OAZAJ,EAAUW,KACVV,EAAOQ,EAEHC,GAAa,GACfE,aAAaT,GACbA,EAAU,KACVC,EAAWG,EACXL,EAASJ,EAAKU,MAAMR,EAASC,GAC7BD,EAAUC,EAAO,MACPE,IACVA,EAAUU,WAAWR,EAAOK,IAEvBR,CACR,CACH;;;;;;;;;;;;;;;;;;;;;;OCKe,MAMb,WAAAY,CAAYC,EAAMC,EAAU,IACpB,kBAAmBC,UAAY,qBAAsBC,SAQ3DP,KAAKQ,SAAU,EAKfR,KAAKK,QAAUI,OAAOC,OAAO,CAC3BC,OAAQ,IACRC,WAAY,MACZC,QAAS,CACPC,MAAO,UACPC,MAAO,gBACPC,QAAS,mBAEX9B,SAAU,IACV+B,OAAQ,OACRC,QAAS,OACTC,UAAW,OACXC,UAAW,QACVf,GAKHL,KAAKI,KAAwB,iBAATA,EAAqBE,SAASe,cAAcjB,GAAQA,EAGpEJ,KAAKI,MACPJ,KAAKsB,OAER,CASD,IAAAA,GAEEtB,KAAKuB,WAAavB,KAAKI,KAAKoB,WAAU,IAEjBC,MAAMC,QAAQ1B,KAAKK,QAAQQ,QAAQC,OACpDd,KAAKK,QAAQQ,QAAQC,MACrB,CAACd,KAAKK,QAAQQ,QAAQC,QAEba,SAAQC,GAAO5B,KAAKuB,WAAWM,UAAUC,IAAIF,KAE1DtB,SAASyB,KAAKC,aAAahC,KAAKuB,WAAYjB,SAASyB,KAAKE,YAG1DjC,KAAKkC,mBAGLlC,KAAKmC,iBAAmBjD,EAASc,KAAKoC,OAAOC,KAAKrC,MAAOA,KAAKK,QAAQnB,UACtEc,KAAKsC,uBAAyBpD,EAASc,KAAKkC,iBAAiBG,KAAKrC,MAAOA,KAAKK,QAAQnB,UAGtFqB,OAAOgC,iBAAiB,SAAUvC,KAAKmC,kBAAkB,GACzD5B,OAAOgC,iBAAiB,SAAUvC,KAAKsC,wBAAwB,GAG/DtC,KAAKK,QAAQY,OAAOuB,KAAKxC,KAC1B,CAQD,gBAAAkC,GACE,MAAMvB,OAAEA,EAAMC,WAAEA,GAAeZ,KAAKK,QACpC,GAAsB,iBAAXM,EACTX,KAAKyC,aAAe9B,MACf,IAAsB,iBAAXA,EAQhB,MAAM,IAAI+B,MAAM,mBAAmB/B,KARE,CACrC,MAAMgC,EAASrC,SAASe,cAAcV,GAEpCX,KAAKyC,aADHE,ED3EH,SAA6BvC,EAAMwC,GACxC,IAAIC,EAAM,EACV,MAAMC,EAAa1C,EAAK2C,aAExB,IAAIC,EAAc5C,EAClB,KAAO4C,GACLH,GAAOG,EAAYC,UACnBD,EAAcA,EAAYE,aAO5B,MAJa,WAATN,IACFC,GAAOC,GAGFD,CACT,CC6D4BM,CAAoBR,EAAQ/B,GAE5B,GAE5B,CAEK,CACF,CAQD,OAAAwC,GACMpD,KAAKuB,YAAcvB,KAAKuB,WAAW8B,YACrC/C,SAASyB,KAAKuB,YAAYtD,KAAKuB,YAEjChB,OAAOgD,oBAAoB,SAAUvD,KAAKmC,kBAC1C5B,OAAOgD,oBAAoB,SAAUvD,KAAKsC,wBAE1CtC,KAAKK,QAAQe,UAAUoB,KAAKxC,KAC7B,CAMD,KAAAe,GACOf,KAAKQ,UACRR,KAAKuB,WAAWM,UAAU2B,OAAOxD,KAAKK,QAAQQ,QAAQG,SACtDhB,KAAKuB,WAAWM,UAAUC,IAAI9B,KAAKK,QAAQQ,QAAQE,OACnDf,KAAKQ,SAAU,EACfR,KAAKK,QAAQa,QAAQsB,KAAKxC,MAE7B,CAMD,OAAAgB,GACMhB,KAAKQ,UACPR,KAAKuB,WAAWM,UAAU2B,OAAOxD,KAAKK,QAAQQ,QAAQE,OACtDf,KAAKuB,WAAWM,UAAUC,IAAI9B,KAAKK,QAAQQ,QAAQG,SACnDhB,KAAKQ,SAAU,EACfR,KAAKK,QAAQc,UAAUqB,KAAKxC,MAE/B,CAMD,MAAAoC,ID/IkC,iBAAnB7B,OAAOkD,QACdlD,OAAOkD,SACNnD,SAASoD,iBAAmBpD,SAASyB,KAAKsB,YAAc/C,SAASyB,MAAM4B,WC8I3D3D,KAAKyC,aACtBzC,KAAKe,QAELf,KAAKgB,SAER"}